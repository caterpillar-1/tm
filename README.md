# TM & PDA - NJU FLA 2024 实验

## HOWTO

- 运行本项目

    ```sh
    # [ARGS] 即为手册中传给 ./fla 的参数
    $ cargo run -- [ARGS]
    ```

## 分析和设计思路

### 解析器 `parse.rs`

观察 TM 和 PDA 程序的语法，发现十分类似，因此将解析器抽象出来，将第一步的解析结果存入构型 `Config` 中。

删掉注释和空格后，一共只有如下情况

- 行不为空且以 `#` 开头

    结果放进 `Config` 的键值对集合中

    - 解析集合
    - 解析字符串

- 行不为空且不以 `#` 开头 

    这是一个转移，直接用 `Vec<_>` 存起来，交给特化的解析器进一步解析

为 `TuringMachine` 和 `PushDownAutomata` 实现 `FromStr` trait 即可完成解析器。主要完成以下工作：

- 检查所有需要定义的项目是否都已定义，是否多定义？
- 检查这些项目的类型是否正确（如 `Q` 是集合，`q0` 是字符串，`z0` 是字符）
- 对状态转移做严格检查

Rust 丰富的标准库 API，使得上述字符串解析工作十分容易进行。

### DTM `tm.rs` 和 PDA `pda.rs`

应该区分程序 (`TuringMachine`, `PushDownAutomata`) 和运行时 (`{tm,pda}::ArchState`)。

程序是 TM，PDA 数学上的元组描述，运行时还包含了状态信息 (TM 的纸带、PDA 的栈和剩余输入等)。

由于两者的执行过程可以抽象为外界不断调用 `step` 和 `Display::fmt`，其实可以用 `trait` 来统一 TM 和 PDA 的创建和执行。但是本项目一开始是参照 2021 版实验手册写的，没有考虑到这一点，暂时没有重构。如果明年的实验还有 DFA，那么这一层抽象就很有必要了。

## 实验完成度

- 解析器、模拟器所有功能已完成
- 完成了 TM，PDA 的 verbose 模式
- 实现了**完备的错误处理**，能够分辨各类语法错误，程序简单地调用异常类型的 `Debug::fmt` 显示程序的语法错误，这在自己编写 TM, PDA 程序时非常有用
- 完成了 TM，PDA 程序的编写，自测通过

## 实验中遇到的问题及解决方法

- 发现了 2021 版手册中对 `*` 转移描述不够清楚的问题，该问题已经在 2024 版手册中修复。
- 由于自己没有考虑周全，对“停机”和“接受”产生疑议。感谢助教 sy 的指点🙏。

## 感想和建议

感谢助教允许我使用 Rust 语言完成本次实验。
